<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>4. api</title>

    <!-- Theme used for syntax highlighting of code -->
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="lib/css/atom-one-light.css" />

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/hogent.css" />

    <!-- pieter overrides -->
    <link rel="stylesheet" href="plugin/codestepper/codestepper.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi)
        ? 'css/print/pdf.css'
        : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section
          class="title-slide"
          data-transition="none"
          data-background-transition="none"
        >
          <img class="title-img" src="img/babyyoda4.png" />
          <h2>use the api</h2>
          <h4>Karine Samyn, Stefaan De Cock, Pieter Van Der Helst</h4>
          <footer class="footer">
            "What one programmer can do in one month, two programmers can do in
            two months." - Fred Brooks
          </footer>
        </section>
        <section class="contents-slide">
          <h3>overview.</h3>
          <ol>
            <li>
              <a href="#/whatisasync">intro</a> <br />
              <span> what is an async call? </span>
            </li>
            <li>
              <a href="#/callbacks">callbacks</a><br />
              <span>using callbacks to handle async</span>
            </li>
            <li>
              <a href="#/promises">promises</a><br />
              <span>how and why do promises handle async better</span>
            </li>
            <li>
              <a href="#/observables">observables</a><br />
              <span>the new kid in town to handle async</span>
            </li>

            <li>
              <a href="#/recipefilter">recipe filter</a><br />
              <span>using a Subject observable to create a recipe filter</span>
            </li>
            <li>
              <a href="#/httpclientmodule">HttpClientModule</a><br />
              <span>how to make http calls in Angular </span>
            </li>
            <li>
              <a href="#/recipedataservice">RecipeDataService</a><br />
              <span>using the http module in our service</span>
            </li>
            <li>
              <a href="#/asyncpipe">async pipe</a><br />
              <span>display async data using the async pipe</span>
            </li>
            <li>
              <a href="#/errorhandling">error handling</a><br />
              <span>how to handle observable errors</span>
            </li>
            <li>
              <a href="#/httppost">http post</a><br />
              <span>how to make a http post call</span>
            </li>
          </ol>
        </section>
        <section>
          <h3>recipe app startpoint</h3>
          <div>
            <img
              src="img/facebooklogo.png"
              alt=""
              style="border:none; box-shadow: none; transform:matrix(0.58,-0.13,0.13,0.58,-140,0);"
            />
            <img
              src="img/beer.png"
              alt=""
              style="position: absolute; border:none; box-shadow: none; top: 60px; left: 100px; transform:matrix(0.37,0.17,-0.17,0.37,200,-140);"
            />
          </div>

          if you spent last class on facebook (or at the pub), branch the repo
          at the correct commit and follow along!
          <p></p>
          <pre data-trim class="console">
<span class='prompt'>~$</span> git clone https://github.com/Pieter-hogent/recipeapp.git  (or git pull)
<span class='prompt'>~$</span> cd recipeapp
<span class='prompt'>~/recipeapp$</span> npm install
<span class='prompt'>~/recipeapp$</span> git checkout -b mybranch <span class="githubcommit">4b40342</span>
        </pre>
        </section>
        <section>
          <h3>Observable</h3>
          <ul>
            <li>
              Connecting with our (or any) API is done using Angular's
              <span class="ilcode">HttpClientModule</span>
            </li>
            <li>
              it neatly wraps performing an XHR: easily set headers, cope with
              errors, response types, progress indicators, and so on
            </li>
            <li>
              the async response is handled using an
              <span class="ilcode">Observable</span>, which we'll explain first
            </li>
            <li>
              (note that before Angular 4.3, this was handled by HttpModule, not
              HttpClientModule, don't include the wrong one)
            </li>
          </ul>
        </section>
        <section id="whatisasync">
          <h3>what is async?</h3>
          <div codesteps>
            <pre
              class="typescript"
            ><code class='codesteps' data-noescape data-trim>
              <span hstep='3'>let notAMoon</span> = <span hstep='2'>buildDeathStar()</span>;
              <span hstep='5'>let alderaan</span> = <span hstep='4'>destroyPlanet(notAMoon)</span>;
              <span hstep='7'>let disturbedForce</span> = <span hstep='6'>aMillionVoicesCriedOut(alderaan)</span>;
            </code></pre>
            <div explanation>
              <span step="1"
                >synchronous programming is calling a function, and waiting for
                the response before you call the next function</span
              >
              <span step="2">the first function is called</span>
              <span step="3"
                >the program waits for the function to finish and assigns the
                result</span
              >
              <span step="4"
                >and only then, the next function starts executing</span
              >
              <span step="5-7">and so on</span>
              <span step="8"
                >until the program is finished, it's easy to follow along and
                reason about synchronous code</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>what is async?</h3>
          <div codesteps no-highlight-first>
            <pre
              class="typescript"
            >  <code class='codesteps' data-noescape data-trim>
                let <span hstep='7'>notAMoon</span> = <span hstep='6'>buildADeathStarAsync()</span>;
                let bobbaFett = createACloneArmyAsync();<span sstep='5+'>

                ...
                
                let alderaan = destroyPlanet(<span hstep="7">notAMoon</span>);</span>
                </code></pre>

            <div explanation>
              <span step="1"
                >but sometimes, completing a function takes a long time, and the
                next function is not dependent on the result of the previous
                one</span
              >
              <span step="2"
                >we'd like to start creating the clone army while the death star
                is still being built</span
              >
              <span step="3"
                >that's what asynchronous programming is (in a nutshell), not
                waiting for a function to finish before you start the next
                one</span
              >
              <span step="4">this leads to a couple of difficulties...</span>
              <span step="5"
                >when can you start using the result of an asynchronous
                function?</span
              >
              <span step="6"
                >remember, we're not waiting for the result of
                buildADeathStarASync</span
              >
              <span step="7"
                >so it's possible <span class="ilcode">notAMoon</span> doesn't
                hold the result yet, while we're trying to use it</span
              >
              <span step="8"
                >solving this is what async programming is all about</span
              ><span step="8"> and deceptively difficult</span>
            </div>
          </div>
        </section>
        <section>
          <h3>async solutions</h3>
          <ul>
            <li>
              there are multiple ways to cope with this, you can simply 'wait'
              for the other function to finish, using mutexes, barriers, ...
            </li>
            <li>
              we don't do that in javascript though, we use higher level
              constructs: you've already learned about callbacks and promises
            </li>
            <li>
              let's do a quick recap of how they work, and then introduce
              another way to handle async functionality: observables
            </li>
          </ul>
        </section>
        <section id="callbacks">
          <h3>callbacks</h3>
          <div codesteps>
            <pre
              class="typescript"
            >  <code class='codesteps' data-noescape data-trim>
            function longAsyncOperation(<span sstep='3+'>callbackParameter</span>) {
              // loooong operation
              <span sstep='1-2'>return </span><span sstep='3+'>callbackParameter(</span>calculation<span sstep='3+'>)</span>;
            }

            <span sstep='1-3'>let result = </span>longAsyncOperation(<span sstep='4+'>doSomethingWithResult</span>);<span sstep='1-3'>
            doSomethingWithResult(result);</span>
            doOtherStuffThatDoesntNeedResult();
            </code></pre>
            <div explanation>
              <span step="1"
                >so our problem is that we don't want to wait (a long time) for
                the result but already start processing other stuff
              </span>
              <span step="2"> one way to do this is using callbacks</span>
              <span step="2">
                i.s.o. returning the result and processing the returned result,
                we pass the processing function as a parameter to the long
                operation!</span
              >
              <span step="3"
                >so we change the long operation to receive a processing
                parameter</span
              >
              <span step="3"
                >it no longer returns a result, it calls the processing
                parameter on the result</span
              >
              <span step="4"
                >functions are first class citizens of javascript, so all that's
                left is simply passing the function name of the processing
                function to this long operation</span
              >
              <span step="5"
                >now other functions can be called while the long operation is
                processing, and as soon as the result is available, the callback
                will be called to process the result</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>multi threaded javascript</h3>
          <ul>
            <li>
              javascript (for now) is always single threaded, concurrency is
              handled using an event loop and a message queue
            </li>
            <li>
              every still-needs-processing (async) function become messages on
              the message queue
            </li>
            <li>
              the event loop will always pop the oldest message, process it, pop
              the oldest message, process it, ...
            </li>
            <li>
              (to make it slightly confusing, it's javascript after all, the
              browser it's own API methods can run in parallel)
            </li>
            <li>let's look at a small example to illustrate this</li>
          </ul>
        </section>
        <section>
          <div class="fragment" code-step svg-step>
            <svg
              id="svg1"
              class="svg-section"
              width="100%"
              height="100%"
              preserveAspectRatio="xMidYMid"
              snapfile="img/js_event_loop.svg"
            >
              <use xlink:href="plugin/codestepper/loaders.svg#myloader"></use>
            </svg>
          </div>
        </section>
        <section>
          <h3>callback hell</h3>
          <ul>
            <li>
              the callback idiom works fine if the callback is a small,
              isolated, function
            </li>
            <li>
              but if the callback basically boils down to "the rest of the
              program", it will have callbacks itself...
            </li>
            <li>...whom have callbacks themselves, and so on, and so on</li>
            <li>
              leading to 'callback hell', the name already suggests this is not
              the most fun thing in the world
            </li>
          </ul>
        </section>
        <section>
          <h3>callback hell</h3>
          <div codesteps>
            <pre
              class="typescript"
            >  <code class='codesteps' data-noescape data-trim>
              createGalacticEmpire(function (error, empire) {
                if (!error) {
                  empire.buildADeathStar(function (notAMoon) {
                    notAMoon.destroyPlanet(function (error, alderaan) {
                      if (error) {
                        throw new Exception(error.msg);
                      } else {
                        alderaan.eliminateRebels(function (disturbance) {
                          ....
                        })
                      }
                    })
                  })
                } else {
                  console.log(error.message());
                }
              })	    
            </code></pre>
            <div explanation>
              <span step="1"
                >even for this relatively small example you can already tell
                code like this gets complicated fast</span
              >
              <span step="2"
                >what is the flow of this function? is every error
                handled?</span
              >
              <span step="2"
                >you need to 'dig in' to understand what's happening (and what's
                not)</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>callback problems</h3>
          <div codesteps>
            <pre
              class="typescript"
            >  <code class='codesteps' data-noescape data-trim>
            function slowAsync(callback) {

            }
            function anotherAsync(callback) {

            }

            let processAfterBoth = ...

            // How can I call processAfterBoth ONLY if both have finished??
            slowAsync( ??? )
            anotherAsync( ??? )
            
            </code></pre>
            <div explanation>
              <span step="1">
                there are other problems with callbacks, what if you only want
                to continue after multiple parallel functions have
                finished?</span
              >
              <span step="2"
                >this can be solved, but it requires keeping track of all
                functions and their state</span
              >
              <span step="2"
                >it makes for even harder to read and reason about code</span
              >
            </div>
          </div>
        </section>
        <section id="promises">
          <h3>promises</h3>
          <div codesteps>
            <pre
              class="typescript"
            >  <code class='codesteps' data-noescape data-trim>
              let <span hstep='2'>deathStarPromise</span> = buildADeathStarAsync();
              let army = <span hstep='3'>buildCloneArmyAsync()</span>;
              <span sstep='4+'>deathStarPromise.then(notAMoon => notAMoon.destroyPlanet());</span>
              <span sstep='5+'>let luke = meetYourDad();</span>
              <span sstep='6+'>deathStarPromise.catch(error => console.log(error));</span>
          </code></pre>
            <div explanation>
              <span step="1">you've learned about promises in web2</span>
              <span step="1"
                >the idea is to represent the result of an asynchronous
                operation, which you can pass around and with which you can
                interact at any time</span
              >
              <span step="2"
                >so you start an async operation, and <i>immediately</i> get a
                result, while the async operation runs</span
              >
              <span step="2"
                >obviously it doesn't hold the final value yet, it's a
                placeholder</span
              >
              <span step="3" style="width: 120%"
                >so if other function calls follow the
                <span class="ilcode">buildADeathStarAsync</span>, they are
                immediately started, there's no waiting for the
                <span class="ilcode">buildADeathStarAsync</span> to finish</span
              >
              <span step="4" style="width: 120%"
                >you interact with this future value by calling a
                <span class="ilcode">then</span> function with a callback, this
                callback will be called as soon as the
                <span class="ilcode">buildADeathStarAsync</span> is
                finished</span
              >
              <span step="5" style="width: 120%"
                >so a <span class="ilcode">then()</span> is not blocking either,
                processing continues until the
                <span class="ilcode">buildADeathStarAsync</span> is completed,
                and then the callback is called</span
              >
              <span step="6" style="width: 120%">
                you can also provide a
                <span class="ilcode">catch()</span> function, which will be
                called if an error occurred during
                <span class="ilcode">buildADeathStarAsync</span>
              </span>
              <span step="7">
                this looks a lot like callbacks (you pass a function that gets
                called when the async function is finished), the difference
                might look subtle, but is important
              </span>
              <span step="8">
                by adding an extra level of indirection, you can 'capture' any
                point in the chain (by keeping the result in a variable), and
                diverge in multiple directions from that point
              </span>
              <span step="8"
                >code is also more readable, as you don't end up with 20 levels
                of indentation</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>callback hell to promise heaven</h3>
          <div codesteps>
            <pre
              class="typescript"
            >  <code class='codesteps' data-noescape data-trim>
                <span sstep='3+'>let empire = </span>createGalacticEmpire(<span sstep='1-2'>function (<span hstep='2'>error</span>, <span hstep='2'>empire</span>) {</span><span sstep='3+'>);</span>
                <span sstep='1-2'>  if (!error) {
                    </span><span sstep='4+'>let notAMoon = </span>empire.<span sstep='3+'>then(e => e.</span>buildADeathStar(<span sstep='1-3'>function (notAMoon) {</span><span sstep='4+'>));</span>
                <span sstep='1-3'>      </span><span sstep='5+'>let alderaan = </span>notAMoon.<span sstep='4+'>then(moon => moon.</span>destroyPlanet(<span sstep='1-4'>function (error, alderaan) {</span><span sstep='5+'>));</span>
                <span sstep='1-4'>        if (error) {
                          throw new Exception(error.msg);
                        } else {
                          </span><span sstep='6+'>let disturbance = </span>alderaan.<span sstep='5+'>then(al => al.</span>eliminateRebels(<span sstep='1-5'>function (disturbance) {</span><span sstep='6+'>));</span><span sstep='1-5'>
                            ....
                          })</span><span sstep='1-4'>
                        }
                      })</span><span sstep='1-3'>
                    })</span><span sstep='1-2'> 
                  } else {
                    console.log(error.message());
                  }
                })</span><span sstep='3+'><span sstep='6+'>
                disturbance.then( () => { ... } );
              </span>
                empire.catch(err => console.log(err.message()));</span><span sstep='5+'>    
                notAMoon.catch(err => throw new Exception(err.msg));</span>
              </code></pre>
            <div explanation>
              <span step="1"
                >remember this example? let's rewrite it with promises to show
                what we mean</span
              >
              <span step="2"
                >every error handling becomes a
                <span class="ilcode">catch</span>, regular callbacks become a
                <span class="ilcode">then</span></span
              >
              <span step="3"
                >you end up with smaller and more readable code</span
              >
              <span step="4"
                >no matter how 'deep' you are in the hierarchy, you can keep
                applying the same conversions</span
              >
              <span step="5">again</span>
              <span step="6"
                >and again, until you have eliminated the 'callback hell'</span
              >
              <span step="7"
                ><i>des goûts et des couleurs on ne discute pas</i></span
              >
              <span step="7"
                >but I think we can all agree the flow became a lot easier to
                grasp</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>promises</h3>
          <ul>
            <li>there's a lot more to say about promises</li>
            <ul>
              <li>how to create them?</li>
              <li>
                what happens when you return a promise from inside a promise?
              </li>
              <li>
                what about <span class="ilcode">Promise.all</span> and
                <span class="ilcode">Promise.race</span>?
              </li>
            </ul>
            <li>
              but we already did that back in web2, and since you all made it
              into web4, I'm sure you're all very versed in these matters
              already
            </li>
          </ul>
        </section>
        <section
          class="gifsection"
          data-background-image="img/hoogspringen.gif"
        >
          <h2 class="giftext">promises perfectly tackle async?</h2>
        </section>
        <section>
          <h3>promises - problems?</h3>
          <ul>
            <li>promises solve async handling pretty well</li>
            <li>
              nothing is ever perfect though, there is room for some improvement
            </li>
            <ul>
              <li>
                once a promise is created it will complete and call the resolve
                (then) or reject (catch) callback, there's no easy way to cancel
                it
              </li>
              <li>
                if a promise failed, given only the promise object there's no
                easy way to 'retry' the promise
              </li>
            </ul>
          </ul>
        </section>
        <section id="observables">
          <h3>observables</h3>
          <ul>
            <li>
              reactive programming, which uses observables, is a fairly new way
              of dealing with asynchronous functions
            </li>
            <li>
              angular uses the RxJS library for this (ºMicrosoft)
            </li>
            <li>
              it's not just javascript, reactive extension exist for pretty much
              every language you'd want to use (java, .net, c++, kotlin, swift,
              python, ...)
            </li>
          </ul>
          <img src="img/rxjs_googletrend.png" alt="" />
        </section>
        <section>
          <h3>observables</h3>
          <ul>
            <li>
              put simply: reactive programming is programming with asynchronous
              data streams
            </li>
            <li>
              we said a Promise is the future result of an operation
            </li>
            <li>
              well, an observable are ALL future results of an operation, and an
              immense toolbox to work with them
            </li>
            <li>
              imperative code 'pulls' data where reactive code 'pushes' data,
              you subscribe to get notified of changes, and those changes are
              pushed to you
            </li>
          </ul>
        </section>
        <section>
          <h3>observables</h3>
          <ul>
            <li>
              you could say an array is a collection of data you get handed (and
              which you'll loop over yourselves)
            </li>
            <img
              src="img/rxjs-marble-array.svg"
              style="background:none; border:none; box-shadow:none;"
              alt=""
            />
            <li>
              and an observable gives you a collection of data, one by one, with
              certain time intervals in between. This is often visualized using
              'marble diagrams', a timeline with some values (shown as circles)
            </li>
            <img
              src="img/rxjs-marble-stream.svg"
              style="background:none; border:none; box-shadow:none;"
              alt=""
            />
            <li>
              <a
                href="https://github.com/ReactiveX/rxjs/blob/master/doc/marble-testing.md"
                >RxJS' test framework</a
              >
              is designed around ASCII drawings of such marble diagrams
            </li>
          </ul>
        </section>
        <section>
          <h3>observables</h3>
          <ul>
            <li>
              this is a lot like responding to user events, e.g. click events
              can be seen as an async event stream, which you observe and
              respond to, a 'stream of clicks'
            </li>
            <li>
              the streams are composable, think of streams as a pipeline of
              operations over your data, you can subscribe to any part of the
              stream or combine them to make new streams
            </li>
            <li>
              working with observables requires a different way of thinking, you
              subscribe to streams, and update your app based on these changes.
              There is very little imperative thinking left
            </li>
            <li>
              more reading about what this is all about?
              <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"
                >"the introduction to reactive programming you've been
                missing"</a
              >
            </li>
          </ul>
        </section>
        <section>
          <h3>observables - operators</h3>
          <ul>
            <li>
              the real power of RxJS comes from the available operators to
              combine and manipulate streams.
            </li>
            <li>
              Just like can apply <span class="ilcode">map</span>,
              <span class="ilcode">filter</span>,
              <span class="ilcode">reduce</span> to arrays to use 'converted'
              arrays, there are operators available to do the same with
              observable streams
            </li>
            <li>
              but there are many (many) more, let's introduce a few to show what
              I mean
            </li>
          </ul>
        </section>
        <section>
          <h3>observables - map</h3>
          <ul>
            <li>
              just like with an array, there's also a
              <span class="ilcode">map</span> operator, similar to an array, you
              define a function to convert <span class="ilcode">T</span> to
              <span class="ilcode">U</span> and your
              <span class="ilcode">Observable&lt;T&gt;</span> becomes an
              <span class="ilcode">Observable&lt;U&gt;</span>
            </li>
          </ul>
          <img
            src="img/rxjs-marble-map.svg"
            style="background:none; border:none; box-shadow:none;"
            alt=""
          />
        </section>
        <section>
          <h3>observables - delay</h3>
          <ul>
            <li>
              there are operators who work on the timing of your stream, rather
              than the values, e.g. <span class="ilcode">delay</span> will,
              well, delay the values being fired
            </li>
          </ul>
          <img
            src="img/rxjs-marble-delay.svg"
            style="background:none; border:none; box-shadow:none;"
            alt=""
          />
        </section>
        <section>
          <h3>observables - merge</h3>
          <ul>
            <li>
              then there are operators which allow you to combine multiple
              streams together, the simplest one is
              <span class="ilcode">merge</span>, which simply creates a new
              stream firing everything all the other streams do
            </li>
          </ul>
          <img
            src="img/rxjs-marble-merge.svg"
            style="background:none; border:none; box-shadow:none;"
            alt=""
          />
        </section>
        <section>
          <h3>pipeable operators</h3>
          <ul>
            <li>
              this is just the tip of the iceberg, there are many (many) more,
              allowing you to sometimes do really cool stuff with little code
            </li>
            <li>
              they are called
              <a
                href="https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"
                >pipeable operators</a
              >
            </li>
            <li>
              (until 12 januari 2018 they were called 'lettable operators', if
              you google)
            </li>
            <li>
              <a href="https://rxmarbles.com/">RxMarbles.com</a> has a great
              visual overview of many of these
            </li>
            <li>
              but there are many more resources to learn these, and more pop up
              every day, reactive programming is on the rise, and not just in
              the web world
            </li>
          </ul>
        </section>

        <section id="recipefilter">
          <h3>recipe filter</h3>
          <div codesteps>
            <pre
              class="typescript"
            >src/app/recipe/recipe-list/recipe-list.component.ts  <code class='codesteps' data-noescape data-trim>
                <span sstep='2+'>import { Subject } from 'rxjs';
    
                  </span>export class RecipeListComponent {
                    public filterRecipeName: string;<span sstep='2+'>
                    public filterRecipe<span hstep='4'>$</span> = new Subject&lt;string&gt;();</span>
                  
                    constructor(private _recipeDataService: RecipeDataService) {<span sstep='5+'>
                      this.filterRecipe$.subscribe(
                        val => this.filterRecipeName = val);
                      }</span>
                    }
                  } 
            </code></pre>
            <div explanation>
              <span step="1"
                >as an example, let's update our recipe filter from chapter 2 to
                become a 'live' filter, that responds as you type (and not only
                after clicking a button)
              </span>
              <span step="2">
                we'll store the input field value in an observable, we use a
                <a href="http://reactivex.io/documentation/subject.html"
                  >Subject</a
                >
                for this
              </span>
              <span step="3">
                Subjects can function both as an observer and as an observable,
                here we'll only use it to emit new values
              </span>
              <span step="3"
                >every letter that is typed, is a new 'event' on the
                stream</span
              >
              <span step="4">
                by convention, observable variables' names end in a $ (stream),
                similar to the _ at the start of private properties
              </span>
              <span step="5">
                so the observable will 'fire' new values in a 'stream', if you
                want to act on those you have to subscribe
              </span>
              <span step="6">
                unlike promises, observables only 'start' when someone
                subscribes (explictly or implicitly)
              </span>
            </div>
          </div>
        </section>
        <section>
          <h3>recipe list</h3>
          <div codesteps>
            <pre
              class="html"
            >src/app/recipe/recipe-list/recipe-list.component.html  <code class='codesteps' data-noescape data-trim>
              &lt;mat-form-field&gt;
                &lt;input matInput <span sstep='2+'>(keyup)='<span hstep='3'>filterRecipe$.next</span>($event.target.value)'</span>
                  type='text' 
                  placeholder='filter recipe name...' <span sstep='1-2' sl>#filter</span>&gt;
              &lt;/mat-form-field&gt;      
              <span sstep='1-2' sl>&lt;button (click)="applyFilter(filter.value)" mat-raised-button&gt; 
                filter
              &lt;/button&gt; </span>
            </code></pre>
            <div explanation>
              <span step="1-2">
                on the html side, we'll remove the button and add a keyup event
                listener
              </span>
              <span step="3">
                everytime a keyup happens, we 'next' a new value in our stream,
                triggering all subscribers their subscribe functions
              </span>
              <span step="4">
                that's it,
                <a href="http://localhost:4200/">let's try this out</a>
              </span>
            </div>
          </div>
        </section>
        <section>
          <h3>recipe list</h3>
          <div codesteps>
            <pre
              class="typescript"
            >src/app/recipe/recipe-list/recipe-list.component.ts  <code class='codesteps' data-noescape data-trim>
                <span sstep='8+'>import { distinctUntilChanged, debounceTime,
                    map, filter } from 'rxjs/operators';
                  
                </span>constructor(private _recipeDataService: RecipeDataService) {
                  this.filterRecipe$<span sstep='2+'>
                    .pipe(<span sstep='3+'>
                      distinctUntilChanged()</span><span sstep='4+'>,
                      debounceTime(400)</span><span sstep='5+'>,
                      map(val => val.toLowerCase())</span><span sstep='6+'>,
                      filter(val => !val.startsWith('s'))</span>
                    )</span>
                    .subscribe(val => (this.filterRecipeName = val));
                } 
            </code><span class="githubcommit">87dd96b</span></pre>
            <div explanation>
              <span step="1">
                this works, but the real power comes from applying the pipeable
                operators
              </span>
              <span step="2">
                you do this by passing one or more function to the pipe function
                on an observable
              </span>
              <span step="3">
                let's say you only want to get called when the input changes
              </span>
              <span step="4">and then only once every 400 milliseconds</span>
              <span step="5">
                and you want to convert the filter to lowercase before passing
                it
              </span>
              <span step="6">
                and then only pass those not starting with an 's'
              </span>
              <span step="7">
                and so on, and so on, these are really powerful things
              </span>
              <span step="8">they can all be found in 'rxjs/operators'</span>
              <span step="9">
                <a href="http://localhost:4200">let's try this</a>
              </span>
            </div>
          </div>
        </section>
        <section>
          <h3>pipeable operators</h3>
          <ul>
            <li>
              one last remark before we get to http, the
              <span class="ilcode">pipe()</span> syntax where you pass other
              functions is rather new
            </li>
            <li>
              so on google, stackoverflow... you'll often find code with the
              following syntax
              <pre class="typescript"><code data-noescape data-trim>
      import 'rxjs/add/operator/map'
      import 'rxjs/add/operator/distinctUntilChanged'
      
      this.filterRecipe$
        .distinctUntilChanged()
        .debounceTime(400)
        .map(val => val.toLowerCase());
                  </code></pre>
            </li>
            <li>
              DON'T DO THAT ANYMORE, it's always easily converted to the new
              syntax
            </li>
          </ul>
        </section>
        <section>
          <h3>http - observables</h3>
          <ul>
            <li>
              in Angular, http request will always return an observable
            </li>
            <li>
              this is done so you can easily cancel and retry requests (http
              responses are not real 'streams' of data, there is always just one
              result)
            </li>
          </ul>
        </section>
        <section id="httpclientmodule">
          <h3>HttpClientModule</h3>
          <div codesteps>
            <pre
              class="typescript"
            >src/app/recipe/recipe.module.ts  <code class='codesteps' data-noescape data-trim>
                @NgModule({
                  declarations: [
                    RecipeComponent,
                    IngredientComponent,
                    RecipeListComponent,
                    AddRecipeComponent,
                    RecipeFilterPipe
                  ],
                  imports: [
                    CommonModule,<span sstep='2+'>
                    HttpClientModule,</span>
                    MaterialModule
                  ],
                  exports: [RecipeListComponent]
                })
                export class RecipeModule {}           
            </code></pre>
            <div explanation>
              <span step="1"
                >first we need to add the
                <span class="ilcode">HttpClientModule</span></span
              >
              <span step="2"
                >start by adding <span class="ilcode">HttpClientModule</span> to
                the app module (remember: <i>NOT</i> HttpModule)</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>CORS</h3>
          <ul>
            <li>
              before we can use our API from Angular we have to make sure our
              cross domain calls work (http on port 4200 to https on port 5001
              doesn't work out of the box)
            </li>
            <li>
              for security reasons, web browsers do not allow Ajax requests to
              servers other than the site you're visiting ('same-origin policy')
            </li>
            <li>
              while developing it's easiest to set up a proxy server (for our
              webpack) to handle this
            </li>
          </ul>
        </section>
        <section>
          <h3>Proxy</h3>
          <div codesteps>
            <pre
              class="javascript"
            >./proxy.conf.json  <code class='codesteps' data-noescape data-trim>
                {
                  "<span hstep='2'>/api</span>": {
                    "target": {
                      "host": "localhost",
                      "protocol": "https:",
                      "port": 5001
                    },
                    "secure": false,
                    "changeOrigin": true,
                    "logLevel": "info"
                  }
                }
            </code></pre>
            <div explanation>
              <span step="1"
                >create a new file <span class="ilcode">proxy.conf.json</span>,
                inside the root of our app (next to
                <span class="ilcode">package.json</span>) with the following
                contents
              </span>
              <span step="2" style="width: 120%"
                >this means that every call to /api will be redirected to
                https://localhost:5001/api</span
              >
              <span step="3" style="width:120%"
                >so e.g. http://localhost:4200/api/recipes becomes
                https://localhost:5001/api/recipes</span
              >
              <span step="3" style="width:120%"
                >but http://localhost:4200/recipes remains
                http://localhost:4200/recipes, exactly what we want</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>Proxy</h3>
          <pre data-trim class="console">
    <span class='prompt'>~$</span> ng serve --proxy-config proxy.conf.json
            </pre>
          <ul>
            <li>
              if you want to use this you have to pass it as a command line
              parameter
            </li>
            <li>
              let's add it to the package.json scripts so we don't have to type
              this every time
            </li>
          </ul>
          <div>
            <pre>package.json<code data-noescape data-trim>
    "scripts": {
      "start": "ng serve --proxy-config proxy.conf.json",  
    }
              </code></pre>
            <div>
              <ul>
                <li>
                  so from now on, we no longer start our environment with 'ng
                  serve' but with 'npm start'
                </li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h3>environment.</h3>
          <ul>
            <li>
              we'd rather not have our backend url hardcoded in the source code
            </li>
            <li>
              it's also not unlikely we'd use a different backend server during
              production and when developing, Angular uses the environment
              mechanism for this
            </li>
            <li>
              by default you have an
              <span class="ilcode">environments</span> folder in the root folder
              with two files, one regular and one for production
            </li>
            <li>
              we'll add a new variable <span class="ilcode">apiUrl</span> to
              both, pointing to '/api', which is where our frontend can find our
              backend
            </li>
            <pre>environments/environment.ts<code data-noescape data-trim>
                export const environment = {
                  production: false,
                  apiUrl: '/api'
                };
                          </code></pre>
          </ul>
        </section>
        <section id="recipedataservice">
          <h3>recipedataservice.</h3>
          <div codesteps>
            <pre
              class="typescript"
            >src/app/recipe.data.service.ts <code class='codesteps' data-noescape data-trim>
                <span sstep='2+'>import { HttpClient } from '@angular/common/http';<span sstep='7+'>
                import { map } from 'rxjs/operators';</span>
                
                </span>@Injectable({
                  providedIn: 'root'
                })
                export class RecipeDataService {
                  <span sstep='1-2'>private _recipes = RECIPES;
                  </span>constructor(<span sstep='2+'>private http: HttpClient</span>) {}

                  get recipes<span sstep='5+'>$</span>(): <span sstep='5+'>Observable&lt; </span>Recipe[]<span sstep='5+'> &gt;</span> {
                  <span sstep='1-2'>  return this._recipes;
                  </span><span sstep='4+'>  return this.http.get(`${environment.apiUrl}/recipes/`))<span sstep='6+'>.pipe(<span sstep='7+'>
                      map(<span sstep='8+'>
                        (list<span hstep='10'>: any[]</span>)<span hstep='10'>: Recipe[]</span> => <span sstep='8'>{}</span><span sstep='9+'>list.map(Recipe.fromJSON)</span>              
                      </span>)
                    </span>)</span>;
                  </span>}
                }
            </code></pre>
            <div explanation>
              <span step="1"
                >we'll update the data service to do all communication with our
                API
              </span>
              <span step="1"
                >you'll typically keep API access contained in your
                services</span
              >
              <span step="2"
                >we start by injecting the
                <span class="ilcode">HttpClient</span></span
              >
              <span step="2"
                >making it available as
                <span class="ilcode">this.http</span></span
              >
              <span step="3"
                >we no longer use the mock object, nor will we keep a copy of
                the recipes in our service</span
              >
              <span step="4"
                >we'll return the result of a
                <span class="ilcode">http.get</span> request, this is an async
                operation, and it returns an Observable</span
              >
              <span step="4"
                >notice how we use the environment variable here</span
              >
              <span step="4"
                >when the request is completed it will 'push' a json array to
                the stream</span
              >
              <span step="5"
                >so our <span class="ilcode">get recipes()</span> will become
                async as well, we will return an Observable to an array of
                Recipes</span
              >
              <span step="5"
                >now we still need to convert the json array from the API, to an
                array of our Recipe model objects</span
              >
              <span step="6"
                >you can perform all kind of conversions by piping the result
                through various RxJS operators</span
              >
              <span step="7"
                >for example, the <span class="ilcode">map</span> operator,
                which you supply a function to, to convert the object wrapped in
                the observable</span
              >
              <span step="8" style="width: 120%"
                >in our case, we got an
                <span class="ilcode">Observable&lt;any[]&gt;</span> from
                http.get, and want an
                <span class="ilcode">Observable&lt;Recipe[]&gt;</span></span
              >
              <span step="8"
                >so we supply a function that converts an
                <span class="ilcode">any[]</span> to a
                <span class="ilcode">Recipe[]</span></span
              >
              <span step="9"
                >we achieve this by calling the javascript map function on the
                any array, converting each element using the
                <span class="ilcode">fromJSON</span> static method we created
                before</span
              >
              <span step="10"
                >adding explicit types to the arrow function signature is of
                course not required, but this is typically one of those spots
                where static type checking can really help you</span
              >
              <span step="11"
                >that's it, not a lot of code, but a lot is happening here; it's
                important to really understand this</span
              >
              <span step="11"
                >now all that's left is subscribing to this service where we
                need the data</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>http.</h3>
          <div codesteps>
            <pre
              class="typescript"
            >src/app/recipe/recipe-list/recipe-list.component.html <code class='codesteps' data-noescape data-trim>
                export class RecipeListComponent {
                  // ....

                  get recipes<span sstep='2+'>$</span>(): <span sstep='2+'>Observable&lt;</span>Recipe[]<span sstep='2+'>&gt;</span> {
                    return this._recipeDataService.recipes<span sstep='2+'>$</span>;
                  }
                
                } 
            </code></pre>
            <div explanation>
              <span step="1">our app component will have a compile error </span>
              <span step="2"
                >so we adapt the new property name (with '$'), and change the
                return type to an observable</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>http - observable</h3>
          <ul>
            <li>if we have a look in the browser, nothing will be shown</li>
            <li>the console has an error that tells us what's going wrong</li>
            <img src="img/ngfor_observable_error.png" alt="" />
            <li>
              it basically says <span class="ilcode">ngFor</span> only works for
              <span class="ilcode">Iterables</span> such as
              <span class="ilcode">Arrays</span>
            </li>
            <li>
              inside our html, we loop over our 'recipes' property, but it
              became on Observable of Recipe[], we can no longer simply do that
            </li>
          </ul>
        </section>
        <section>
          <h3>http - observable</h3>
          <ul>
            <li>
              there's more, it's not just that we can't simply loop over the
              result of an Observable, there *is* no result
            </li>
            <li>
              if we would have used Promises, the http call would have already
              happened, we'd only need to adapt the way we show the result
            </li>
            <li>
              but here nothing has happened yet, if you look in the backend
              logs, there's nothing there
            </li>
            <li>
              Observables are 'cold' constructs, as long as nobody subscribes,
              nothing happens
            </li>
            <li>
              so we need to subscribe, wait for the async result, and then
              capture it and loop over the list
            </li>
          </ul>
        </section>
        <section>
          <h3>http - observable</h3>
          <div codesteps>
            <pre
              class="typescript"
            > src/app/recipe/recipe-list/recipe-list.component.ts <code class='codesteps' data-noescape data-trim>
                export class RecipeComponent {
                  <span sstep='2-6'>private _recipes: Recipes[];
                </span><span sstep='7+'>private _fetchRecipes$: Observable&lt;Recipe[]&gt; 
                    = this._recipeDataService.recipes$;
                </span>
                  constructor(private _recipeDataService: RecipeDataService) {<span sstep='3-7'>
                    this._recipeDataService.recipe$.subscribe( 
                      res => this._recipes = res
                    );
                  </span>}
                
                  get recipes<span sstep='1-3,9'>$</span>(): <span sstep='1-3,9+'>Observable&lt;</span>Recipe[]<span sstep='1-3,9+'>&gt;</span> {
                    return <span sstep='9+'>this._fetchRecipes$</span><span sstep='4-8'>this._recipes</span><span sstep='1-3'>this._recipeDataService.recipes$</span>;
                  } 
            </code></pre>
            <div explanation>
              <span step="1"
                >so we could adapt our AppComponent to subscribe, copy the
                results and show those
              </span>
              <span step="2">so add a variable to cache the results</span>
              <span step="3"
                >subscribe to our services, and as the results come in, store
                them in our cache</span
              >
              <span step="4"
                >and change the <span class="ilcode">get recipes</span> to
                return our cache list</span
              >
              <span step="5"
                >this works, and it's not necessarily <i>bad</i></span
              >
              <span step="5">but we are needlessly caching, keeping state</span>
              <span step="5">always avoid keeping state if you can</span>
              <span step="6"
                >this can be solved better using the
                <span class="ilcode">AsyncPipe</span></span
              >
              <span step="6"
                >by adding <span class="ilcode">| async</span> in the html, we
                tell the system to subscribe asynchronously, and return the
                result as soon as it comes in, and move on as normal afterwards
              </span>
              <span step="6">so, exactly what we want</span>
              <span step="7"
                >we add a new variable with a reference to the recipes stream of
                our data service</span
              >
              <span step="8">we no longer subscribe</span>
              <span step="9">and we simply return this new stream</span>
              <span step="9"
                >now all that's left is adding the async pipe in our html</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>http - observable</h3>
          <div codesteps>
            <pre
              class="html"
            > src/app/app.component.html <code class='codesteps' data-noescape data-trim>
            &lt;div&gt;
              &lt;!-- ... --&gt;
              &lt;div fxLayout=&quot;row&quot; [...] &gt;
                &lt;div fxFlex="0 0 calc(25%-0.5%)"
                  *ngFor=&quot;
                    let localRecipe of (recipes<span hstep='1'>$ | async</span> | recipeFilter: filterRecipeName)
                  &quot;
                &gt;
                  &lt;app-recipe [recipe]=&quot;localRecipe&quot;&gt;&lt;/app-recipe&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            
            </code><span class="githubcommit">97466f4</span></pre>
            <div explanation>
              <span step="1">
                in our html code we simply add the
                <span class="ilcode">| async</span> to the the recipes list
              </span>
              <span step="1">
                this will subscribe to the observable, and process the results
                as they arrive</span
              >
              <span step="2">
                you might wonder why we copied the observable in our class, and
                didn't just pass the result of the recipe dataservice to our
                async pipe?</span
              >
            </div>
          </div>
        </section>
        <section id="asyncpipe">
          <h3>async pipe</h3>
          <ul>
            <li>
              change detection! An async pipe whose input resolves triggers a
              change detection cycle
            </li>
            <li>
              so the <span class="ilcode">(recipes$ | async)</span> would
              trigger <span class="ilcode">get recipes()</span> in
              <span class="ilcode">RecipeDataService</span>, which triggers a
              http get call
            </li>
            <li>
              when the http get call resolves, async pipe signals to the change
              detection system that something changed, on this new cycle
              <span class="ilcode">(recipes$ | async)</span> are requested
              again, triggering <span class="ilcode">get recipes()</span> on
              <span class="ilcode">RecipedataService</span> once more, and hence
              a <i>new</i> http get call is triggered
            </li>
            <li>
              which returns a <i>new</i> Observable as well, which returns new
              results, so the async pipe has changed again, and triggers a new
              cycle!
            </li>
            <li>
              and so on and so on, you end up in an endless loop, because a http
              get always creates a new observable, so we have to avoid this
            </li>
            <li><a href="http://localhost:4200">let's try it</a></li>
          </ul>
        </section>
        <section>
          <h3>ingredient model</h3>
          <ul>
            <li>
              so that <i>mostly</i> works, but we get all these
              <span class="ilcode">[Object object]</span>'s for our ingredients
            </li>
            <li>
              this is because our frontend still stores ingredients as strings,
              while the API returns proper Ingredient objects
            </li>
            <li>
              this can be solved by adding an Ingredient model class, adapting
              the ingredient component, and using the model when converting the
              recipe
            </li>
            <li>
              this is <i>extremely</i> similar to what we've done for Recipe, I
              consider this an exercise
            </li>
            <li>
              (if you have trouble with this, it's probably advised to start
              studying for this course)
            </li>
            <li>
              (and if you reeeaally can't figure it out: commit
              <span class="githubcommit">837cc7c</span>)
            </li>
          </ul>
        </section>
        <section>
          <h3>loading...</h3>
          <div codesteps>
            <pre
              class="html"
            >src/app/recipe/recipe-list/recipe-list.component.html  <code class='codesteps' data-noescape data-trim>
              <span sstep='3+'>&lt;div *ngIf=&quot;(recipes$ | async) as recipes; else <span hstep='5'>loading</span>&quot;&gt;
               </span><span hstep='4'> &lt;div
                  fxLayout=&quot;row wrap&quot;
                  fxLayout.xs=&quot;column&quot;
                  fxLayoutWrap
                  fxLayoutGap=&quot;0.5%&quot;
                  fxLayoutAlign=&quot;left&quot;
                &gt;
                  &lt;div
                    *ngFor=&quot;let localRecipe of (recipes<span sstep='1-2'>$ | async</span> | recipeFilter: filterRecipeName)&quot;
                  &gt;
                    &lt;app-recipe [recipe]=&quot;localRecipe&quot;&gt;&lt;/app-recipe&gt;
                  &lt;/div&gt;
                &lt;/div&gt;</span><span sstep='3+'>
              &lt;/div&gt;</span><span sstep='2+'>
              &lt;ng-template #loading&gt;<span hstep='5'>&lt;mat-spinner&gt;&lt;/mat-spinner&gt;</span>&lt;/ng-template&gt;</span>
            </code></pre>
            <div explanation>
              <span step="1"
                >our recipes load asynchronously, depending on the speed of the
                network (and server) this could take a while
              </span>
              <span step="1"
                >it would be better if we could show a 'loading' message (or
                animation)</span
              >
              <span step="2"
                >to achieve this, first we add an
                <span class="ilcode">ng-template</span> with a material design
                spinner which we'll show while loading
              </span>
              <span step="2"
                ><span class="ilcode">ng-template</span>'s define html building
                blocks, which are not shown until you explicitly include
                them</span
              >
              <span step="3"
                >to show either the list of recipes, or our loading message, we
                use an <span class="ilcode">*ngIf</span></span
              >
              <span step="3"
                >just like <span class="ilcode">*ngFor</span> loops,
                <span class="ilcode">*ngIf</span> gives us a conditional
                expression
              </span>
              <span step="4"
                >all children of the tag containing the
                <span class="ilcode">*ngIf</span> are shown if the condition is
                met</span
              >
              <span step="4"
                >(in this case, if your
                <span class="ilcode">AsyncPipe</span> resolves, and the results
                are put in <span class="ilcode">recipes</span>)</span
              >
              <span step="5"
                >and if not (<span class="ilcode">else</span> case) we show an
                <span class="ilcode">ng-template</span> defined elsewhere</span
              >
              <span step="5"
                ><span class="ilcode">mat-spinner</span> can be found in the
                MatProgressSpinnerModule</span
              >
              <span step="6"
                >testing this is bit hard, you're probably not fast enough to
                see if this works (unless if your computer is really old)</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>loading...</h3>
          <div codesteps>
            <pre
              class="typescript"
            >src/app/recipe.data.service.ts  <code class='codesteps' data-noescape data-trim>
                export class RecipeDataService {
                  constructor(private http: HttpClient) {}
                
                  get recipes$(): Observable&lt;Recipe[]&gt; {
                    return this.http.get(`${environment.apiUrl}/recipes/`).pipe(<span sstep='1'>
                      <span hstep='1'>delay(2000),</span></span>
                      map((list: any[]): Recipe[] => list.map(Recipe.fromJSON))
                    );
                  } 
                }
            </code><span class="githubcommit">eb23d85</span></pre>
            <div explanation>
              <span step="1">RxJS to the rescue</span>
              <span step="1"
                >you can pipe through the delay operator first</span
              >
              <span step="1"
                >2 seconds in this example, should be enough to alt-tab and see
                the loading message</span
              >
              <span step="2"
                >don't forget to remove this delay again after you've finished
                testing...</span
              >
              <span step="2"
                ><a href="http://localhost:4200">let's try this out</a></span
              >
            </div>
          </div>
        </section>
        <section id="errorhandling">
          <h3>error handling</h3>
          <ul>
            <li>
              it's important to realize any given stream can only
              <i>error out once</i>
            </li>
            <li>
              streams can complete, ending their lifecycle without any error,
              the stream will no longer produce values
            </li>
            <li>
              an alternative to completion is erroring out, the stream's
              lifecycle ended with an error, it will no longer emit values
            </li>
            <li>
              notice that there is no obligation for a stream to complete or
              error out, both are optional, but they
              <i>are mutually exclusive</i>
            </li>
          </ul>
        </section>
        <section>
          <h3>error handling</h3>
          <ul>
            <li>
              just as Promises have a catch function, you can specify a second
              function when subscribing to Observables to process any errors
              that happened
            </li>
            <li>(and a third, to be called when a stream completes)</li>
            <li>
              but we only subscribe implicitly by using our AsyncPipe, adding
              error handling at the point of our AsyncPipe would be messy
            </li>
            <li>
              once more, we'll rely on an RxJS operator to help us out:
              <span class="ilcode">catchError</span>
            </li>
          </ul>
        </section>
        <section>
          <h3>error handling - service</h3>
          <div codesteps>
            <pre
              class="typescript"
            > src/app/recipe-data.service.ts <code class='codesteps' data-noescape data-trim>
              export class RecipeDataService {
                constructor(private http: HttpClient) {}
              
                get recipes$(): Observable&lt;Recipe[]&gt; {
                  return <span hstep='2'>this.http.get</span>(`${environment.apiUrl}/recipes/`).pipe(<span sstep='1+'>
                    <span hstep='1'>catchError</span>(<span sstep='3+'>handleError</span>),</span>
                    <span hstep='2'>map</span>((list: any[]): Recipe[] => list.map(Recipe.fromJSON))
                  );
                }<span sstep='3+'>

                handleError(err: any)<span sstep='6+'>: Observable&lt;never&gt;</span> {
                  let errorMessage: string;
                  if (err instanceof HttpErrorResponse) {
                    errorMessage = `'${err.status} ${err.statusText}' when accessing '${err.url}'`;
                  } else {
                    errorMessage = `an unknown error occurred ${err}`;
                  }
                  console.error(err);<span sstep='5'>
                  return of([]);</span><span sstep='6+'>
                  return throwError(errorMessage);</span>
                }</span>
              }
            </code></pre>
            <div explanation>
              <span step="1"
                >we add a <span class="ilcode">catchError</span> operator to the
                pipe</span
              >
              <span step="1"
                >like any <span class="ilcode">pipe</span> operator, this one
                gets an input observable and returns an output observable
              </span>
              <span step="2"
                >as long as the original produces no error,
                <span class="ilcode">catchError</span> simply passes the values
                from its input observable to its output observable</span
              >

              <span step="3"
                >when an error occurs however, the function passed to
                <span class="ilcode">catchError</span> is called to deal with
                this error</span
              >
              <span step="4">
                the original stream no longer emits values (an error occurred),
                but we still need a stream to pass in the pipe, so after dealing
                with the error we create a stream ourselves
              </span>
              <span step="4"
                >this is called the
                <span class="ilcode">catch and replace strategy</span></span
              >
              <span step="5"
                >we could simply return an observable created from an empty
                area, which will immediately complete without emitting
                values</span
              >
              <span step="6"
                >or we'll use the static
                <span class="ilcode">throwError</span> function from RxJS, which
                will never return a value but immediatelly error out
                itself</span
              >
              <span step="6"
                >now let's update the component so we can present this error to
                the user</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>error handling - component</h3>
          <div codesteps>
            <pre
              class="typescript"
            > src/app/recipe/recipe-list/recipe-list.component.ts <code class='codesteps' data-noescape data-trim>
                  export class RecipeListComponent implements OnInit {
                    private _fetchRecipes$: Observable&lt;Recipe[]&gt;<span sstep='1-2' sl> = this._recipeDataService
                    .recipes$;</span><span sstep='2+'>
                    public errorMessage: string = '';</span>
                      
                    // [...] 

                    ngOnInit(): void {<span sstep='2+'>
                      this._fetchRecipes$ = this._recipeDataService.recipes$.pipe(
                        catchError(err => {
                          <span hstep='3'>this.errorMessage = err;</span>
                          return EMPTY;
                        })
                      );
                    </span>}
                 
                }
            </code></pre>
            <div explanation>
              <span step="1">
                we'll change how we deal with the fetchRecipes$ stream</span
              >
              <span step="2"
                >we'll pipe it through a <span class="ilcode">catchError</span>,
                to capture the error we rethrow with
                <span class="ilcode">throwError</span></span
              >
              <span step="2"
                >and assign that one to a new variable that will hold the error
                message</span
              >
              <span step="3"
                >so if we never get an error, nothing changes, but if any error
                occurs the <span class="ilcode">this.errorMessage</span> will
                hold it</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>error handling - component</h3>
          <div codesteps>
            <pre
              class="html"
            > src/app/recipe/recipe-list/recipe-list.component.html <code class='codesteps' data-noescape data-trim>
              &lt;div *ngIf=&quot;(recipes$ | async) as recipes; else <span sstep='1'>loading</span><span sstep='2+'>loadingOrError</span>&quot;&gt;
                &lt;div
                  fxLayout=&quot;row&quot;
                &gt;
                  &lt;div *ngFor=&quot;let localRecipe of (recipes | recipeFilter: filterRecipeName)&quot;&gt;
                    &lt;app-recipe [recipe]=&quot;localRecipe&quot;&gt;&lt;/app-recipe&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              <span sstep='3+'>&lt;ng-template #loadingOrError&gt;
                &lt;mat-card class="error" *ngIf=&quot;errorMessage; else loading&quot;&gt;
                  <span hstep='4'> Error loading the recipe list: {{ errorMessage }}. &lt;br/&gt;
                    Please try again later.</span></span>
                  &lt;ng-template #loading&gt;
                    &lt;mat-spinner&gt;&lt;/mat-spinner&gt;
                  &lt;/ng-template&gt;<span sstep='3+'>
                &lt;/mat-card&gt;
              &lt;/ng-template&gt; </span>
            </code><span class="githubcommit">4fd078b</span></pre>
            <div explanation>
              <span step="1"
                >here we do pretty much the same thing we did for loading
                earlier
              </span>
              <span step="2"
                >we change the template shown if the recipes are not loaded
                (it's because they're either still loading, or because an error
                occurred)</span
              >
              <span step="3"
                >the template is very similar to before, if there is no error
                reported on the stream, we're still loading</span
              >
              <span step="4"
                >and as soon as an error occurred, we show the
                <span class="ilcode">errorMessage</span> that was signaled on
                the stream</span
              >
              <span step="5"
                >the easiest way to test this, is to adapt the REST API to
                return a <span class="ilcode">StatusCode(500)</span> when we
                request our recipes</span
              >
              <span step="5"
                ><a href="http://localhost:4200">let's try this out</a></span
              >
            </div>
          </div>
        </section>
        <section id="httppost">
          <h3>http post</h3>
          <div codesteps>
            <pre
              class="typescript"
            > src/app/recipe/recipe-data.service.ts <code class='codesteps' data-noescape data-trim>
              export class RecipeDataService {
              
                constructor(private http: HttpClient) {}
              
                addNewRecipe(recipe: Recipe) {<span sstep='2+'>
                  return this.http
                    .post(`${environment.apiUrl}/recipes/`, <span sstep='3+'>recipe.toJSON()</span>)
                    .pipe(catchError(this.handleError), map(Recipe.fromJSON))<span sstep='4+'>
                    .subscribe();</span>
                  </span>
                }
              }
          </code></pre>
            <div explanation>
              <span step="1">next we'll tackle http POST requests </span>
              <span step="1">luckily this is all very similar to GET</span>
              <span step="2"
                >i.s.o. <span class="ilcode">get</span> we do
                <span class="ilcode">post</span> to the same url we used to
                retrieve recipes</span
              >
              <span step="2"
                >but now we also need to pass a body when performing the
                HttpRequest, with a json representation of our recipe</span
              >
              <span step="3"
                >so we'll simply add a <span class="ilcode">toJSON</span> method
                to recipe and pass that</span
              >
              <span step="3">(not shown, i'm sure you can manage)</span>
              <span step="4"
                >that's it for the data service, but if we'd try now, nothing
                would happen when we click the add recipe button</span
              >
              <span step="4"
                >as said before, Observables are <i>cold</i>, as long as nobody
                subscribes, they do not start</span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>http post</h3>
          <ul>
            <li>
              the recipe gets added, but it doesn't get added to the list of
              recipes automatically, we need to manually refresh
            </li>
            <li>
              while this makes sense (the methods retrieving the recipes can't
              automatically know something was added in the backend) this is not
              what we want
            </li>
            <li>there are essentially two ways around this</li>
            <ul>
              <li>
                you either make sure the list gets refreshed when needed (so a
                GET of all recipes happens everytime a recipe was succesfully
                added or removed)
              </li>
              <li>
                you keep a local cache of the recipes and update it when you add
                or remove a recipe
              </li>
            </ul>
            <li>both have their advantages / disadvantages and their uses</li>
          </ul>
        </section>
        <section>
          <h3>local cache</h3>
          <h4>advantage</h4>
          <ul>
            <li>
              less http requests, meaning a faster webapp, and you need less
              server resources
            </li>
            <li>user action feedback is immediatelly reflected in the UI</li>
          </ul>
          <h4>disadvantage</h4>
          <ul>
            <li>what if multiple people manipulate the data?</li>
            <li>
              even if it's just you, keeping state in sync correctly is HARD
              (see lesson 9)
            </li>
          </ul>
        </section>
        <section>
          <h3>local cache</h3>
          <ul>
            <li>
              it greatly depends on the use case as well, when designing a stock
              market ticker, or an orderpage for tomorrowland tickets you most
              definitely do not want to much caching
            </li>
            <li>
              we'll have a lot more to say about state management later, for now
              we'll create a local array with a copy of the recipes and provide
              observable access to that array
            </li>
            <li>
              I'd like to stress again that this is FAR from a good solution to
              this problem, you just haven't learned enough rxjs to do this
              properly
            </li>
            <li>we'll get back to this...</li>
          </ul>
        </section>
        <section>
          <h3>local copy of the recipes</h3>
          <div codesteps>
            <pre
              class="typescript"
            > src/app/recipe/recipe-data.service.ts <code class='codesteps' data-noescape data-trim>
            export class RecipeDataService {<span sstep='3+'>
              private _recipes$ = new BehaviorSubject&lt;Recipe[]&gt;([]);</span><span hstep='1'>
              private _recipes: Recipe[];</span>
            
              constructor(private http: HttpClient) {<span sstep='2+'>
                this.recipes$.subscribe((recipes: Recipe[]) => {
                  this._recipes = recipes;<span sstep='4+'>
                  this._recipes$.next(this._recipes);</span>
                });</span>
              }<span sstep='3+'>
            
              get allRecipes$(): Observable&lt;Recipe[]&gt; {
                return this._recipes$;
              }</span>
            
              get recipes$(): Observable&lt;Recipe[]&gt; {
                return this.http.get(`${environment.apiUrl}/recipes/`).pipe(
                  catchError(this.handleError),
                  map((list: any[]): Recipe[] => list.map(Recipe.fromJSON))
                );
              }
            
              addNewRecipe(recipe: Recipe) {
                return this.http
                  .post(`${environment.apiUrl}/recipes/`, recipe.toJSON())
                  .pipe(catchError(this.handleError),map(Recipe.fromJSON))
                  .subscribe((rec: Recipe) => {<span sstep='2+'>
                    this._recipes = [...this._recipes, rec];<span sstep='4+'>
                    this._recipes$.next(this._recipes);</span>
                  </span>});
              } 
  </code><span class='githubcommit'></span> </pre>
            <div explanation>
              <span step="1"
                >we'll keep a copy of all recipes in a local array
              </span>
              <span step="1"
                >while we could simply grant access to this array to the
                components, we want to keep our public interface using
                observables (we'll change the inner workings of this class
                later)</span
              >
              <span step="2"
                >we'll initialize the array with the original recipes from the
                backend</span
              >
              <span step="2">and update the list when a recipe is added</span>
              <span step="3"
                >we'll then provide observable access to this list using a new
                subject</span
              >
              <span step="4"
                >and resend the array of recipes whenever it's updated through
                this subjectarray</span
              >
              <span step="5"
                >all that's left now is updating the component to use
                <span class="ilcode">allRecipes</span> i.s.o.
                <span class="ilcode">recipes</span></span
              >
            </div>
          </div>
        </section>
        <section>
          <h3>that's all folks</h3>
          <ul>
            <li>
              this will do for now, we'll tackle this for real when we learn
              about more advanced rxjs operators
            </li>
            <li>
              so that's it for today, we covered a bit of reactive programming
              and how to perform http requests
            </li>
            <li>
              as an exercise try to add a trashcan button to each recipe and
              call a http delete when clicked (solution: see
              <span class="githubcommit">ffec8a5</span>)
            </li>
            <li>
              note that you know most things you need for your task now, we
              still need to cover forms and routing, but if you ignore forms for
              now, and show everything in one big html (so you don't need
              routing yet), you can do pretty much everything needed
            </li>
            <li>so no excuses! start working</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/chart.xkcd.min.js"></script>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="plugin/codestepper/codestepper.js"></script>
    <script src="js/hogent-reveal.js" data-start-at-last="false"></script>
    <script src="js/snap.svg.js"></script>
  </body>
</html>
